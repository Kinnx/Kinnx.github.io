<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Kinnx&#39;s Binary world">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Kinnx&#39;s Binary world">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kinnx">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Kinnx's Binary world</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Kinnx's Binary world</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/22/arm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kinnx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kinnx's Binary world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/22/arm/" class="post-title-link" itemprop="url">arm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-22 11:14:38 / 修改时间：11:14:57" itemprop="dateCreated datePublished" datetime="2022-06-22T11:14:38+08:00">2022-06-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>各位同学，这次分享的资料可分为两个部分D3d和WDDM<br>D3D可以先从了解graphic pipeline开始学习，然后在开始D3D的学习<br>WDDM可以先了解WDM的基础框架，然后深入学习WDDM相关知识<br>希望大家可以边学习边自己上手编程<br>Graphic pipeline视频：<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av90798049?vd_source=69b0ffc126b8bbfb9185e6ba861eb8d1">https://www.bilibili.com/video/av90798049?vd_source=69b0ffc126b8bbfb9185e6ba861eb8d1</a><br>D3D文档：<br><a target="_blank" rel="noopener" href="https://www.3dgep.com/learning-directx-12-1/">https://www.3dgep.com/learning-directx-12-1/</a><br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/direct3d">https://docs.microsoft.com/en-us/windows/win32/direct3d</a><br>WDM和WDDM文档：<br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-wdm">https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-wdm</a><br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/display/introduction-to-the-windows-vista-and-later-display-driver-model">https://docs.microsoft.com/en-us/windows-hardware/drivers/display/introduction-to-the-windows-vista-and-later-display-driver-model</a></p>
<p>更多内部资料<br>Mali Gem：<br><a target="_blank" rel="noopener" href="https://confluence.arm.com/display/GPUDDKPRO/Ramp+up+preparation?preview=/412467666/577110280/mali_gems.pdf">https://confluence.arm.com/display/GPUDDKPRO/Ramp+up+preparation?preview=/412467666/577110280/mali_gems.pdf</a></p>
<p>内部New Starter Training 资料：<br><a target="_blank" rel="noopener" href="https://confluence.arm.com/display/~andnil01/Graphics+Training+Slides">https://confluence.arm.com/display/~andnil01/Graphics+Training+Slides</a><br><a target="_blank" rel="noopener" href="https://confluence.arm.com/display/GPU/Graphics+Training">https://confluence.arm.com/display/GPU/Graphics+Training</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/10/wsl2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kinnx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kinnx's Binary world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/10/wsl2/" class="post-title-link" itemprop="url">wsl2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-10 14:36:07" itemprop="dateCreated datePublished" datetime="2022-06-10T14:36:07+08:00">2022-06-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/08/%E6%B5%B7%E9%87%8F%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kinnx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kinnx's Binary world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/08/%E6%B5%B7%E9%87%8F%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">海量数据排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-08 16:52:47 / 修改时间：16:55:03" itemprop="dateCreated datePublished" datetime="2022-06-08T16:52:47+08:00">2022-06-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="归并思路"><a href="#归并思路" class="headerlink" title="归并思路"></a>归并思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 对 2 亿个数字进行排序, 约 10 G 的文件, 每个数字 int 能表示</span></span><br><span class="line"><span class="comment">// 算法流程</span></span><br><span class="line"><span class="comment">// 将 10 G 的文件散列到 300 个文件中, 每个文件大约 35 MB</span></span><br><span class="line"><span class="comment">// 对 35 MB 的小文件内部排序, 或者分发到多台计算机中, 并行处理 MapReduce</span></span><br><span class="line"><span class="comment">// 最后使用最小堆, 进行 300 路归并排序, 合成大文件</span></span><br><span class="line"><span class="comment">// 再写一个算法判断 2 亿个数字是否有序</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_NUM  300				<span class="comment">// 哈希文件数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH(a)   (a % FILE_NUM)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">6000000</span>;						<span class="comment">// 2 亿个数字, 手动改</span></span><br><span class="line"><span class="type">char</span> path[<span class="number">20</span>] = <span class="string">&quot;c:\\data.dat&quot;</span>;			<span class="comment">// 待排文件</span></span><br><span class="line"><span class="type">char</span> result[<span class="number">20</span>] = <span class="string">&quot;c:\\result.dat&quot;</span>;		<span class="comment">// 排序后文件</span></span><br><span class="line"><span class="type">char</span> tmpdir[<span class="number">100</span>] = <span class="string">&quot;c:\\hashfile&quot;</span>;		<span class="comment">// 临时目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成 2 亿个数字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">write_file</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *out = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n正在生成 %d 个数字...\n\n&quot;</span>, num);</span><br><span class="line">	out = <span class="built_in">fopen</span>(path, <span class="string">&quot;wt&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (out == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> s, e;</span><br><span class="line">	e = s = <span class="built_in">clock</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		e = <span class="built_in">clock</span>();</span><br><span class="line">		<span class="keyword">if</span> (e - s &gt; <span class="number">1000</span>)		<span class="comment">// 计算进度</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r处理进度 %0.2f %%\t&quot;</span>, (i * <span class="number">100.0</span>) / num);</span><br><span class="line">			s = e;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fprintf</span>(out, <span class="string">&quot;%d\n&quot;</span>, </span><br><span class="line">			(<span class="built_in">rand</span>() % <span class="number">31623</span>) * (<span class="built_in">rand</span>() % <span class="number">31623</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(out);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 2 亿个数字进行哈希, 分散到子文件中</span></span><br><span class="line"><span class="comment">// 入口参数: path, tmpdir</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *in = <span class="literal">NULL</span>;</span><br><span class="line">	FILE *tmp[FILE_NUM + <span class="number">5</span>];</span><br><span class="line">	<span class="type">char</span> hashfile[<span class="number">512</span>];		<span class="comment">// 哈希文件地址</span></span><br><span class="line">	<span class="type">int</span> data, add;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r正在哈希 %s\n\n&quot;</span>, path);</span><br><span class="line">	in = <span class="built_in">fopen</span>(path, <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (in == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;FILE_NUM; i++) tmp[i] = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 开始哈希, 核心代码要尽可能的加速</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> s, e;</span><br><span class="line">	e = s = <span class="built_in">clock</span>();</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fscanf</span>(in, <span class="string">&quot;%d&quot;</span>, &amp;data) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		add = <span class="built_in">HASH</span>(data);</span><br><span class="line">		<span class="keyword">if</span> (tmp[add] == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sprintf</span>(hashfile, <span class="string">&quot;%s\\hash_%d.~tmp&quot;</span>, tmpdir, add);</span><br><span class="line">			tmp[add] = <span class="built_in">fopen</span>(hashfile, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fprintf</span>(tmp[add], <span class="string">&quot;%d\n&quot;</span>, data);</span><br><span class="line">	</span><br><span class="line">		i++;</span><br><span class="line">		e = <span class="built_in">clock</span>();			<span class="comment">// 计算进度</span></span><br><span class="line">		<span class="keyword">if</span> (e - s &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r处理进度 %0.2f %%\t&quot;</span>, (i * <span class="number">100.0</span>) / num);</span><br><span class="line">			s = e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;FILE_NUM; i++)</span><br><span class="line">		<span class="keyword">if</span> (tmp[i]) <span class="built_in">fclose</span>(tmp[i]);</span><br><span class="line">	<span class="built_in">fclose</span>(in);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 300 个文件逐个排序, 采用堆排序 STL 的优先队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">fileexist</span><span class="params">(<span class="type">char</span> *path)</span></span>;		<span class="comment">// 判断文件存在</span></span><br><span class="line">	std::priority_queue&lt;<span class="type">int</span>&gt; q;		<span class="comment">// 堆排序</span></span><br><span class="line">	<span class="type">char</span> hashfile[<span class="number">512</span>];</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> i, data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 逐个处理 300 个文件, 或者将这些文件发送到其它计算机中并行处理</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;FILE_NUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(hashfile, <span class="string">&quot;%s\\hash_%d.~tmp&quot;</span>, tmpdir, i);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fileexist</span>(hashfile))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r正在排序 hash_%d.~tmp\t&quot;</span>, i);</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// 小文件从磁盘加入内存中</span></span><br><span class="line">			fp = <span class="built_in">fopen</span>(hashfile, <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;data) != EOF)</span><br><span class="line">			&#123;</span><br><span class="line">				q.<span class="built_in">push</span>(data);</span><br><span class="line">				<span class="comment">// 优先队列默认是大顶堆, 即降序排序</span></span><br><span class="line">				<span class="comment">// 要升序需要重载 () 运算符</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fclose</span>(fp);</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// 排序后再从内存写回磁盘</span></span><br><span class="line">			fp = <span class="built_in">fopen</span>(hashfile, <span class="string">&quot;wt&quot;</span>);		<span class="comment">// 覆盖模式写</span></span><br><span class="line">			<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">top</span>());</span><br><span class="line">				q.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fclose</span>(fp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>		<span class="comment">// 队列结点</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="type">int</span> id;			<span class="comment">// 哈希文件的编号</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;a) <span class="type">const</span></span><br><span class="line">	&#123; <span class="keyword">return</span> data &lt; a.data; &#125;</span><br><span class="line">&#125;node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 300 个有序文件合并成一个文件, K 路归并排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reduce</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">fileexist</span><span class="params">(<span class="type">char</span> *path)</span></span>;</span><br><span class="line">	std::priority_queue&lt;node&gt; q;		<span class="comment">// 堆排序</span></span><br><span class="line">	FILE *file[FILE_NUM + <span class="number">5</span>];</span><br><span class="line">	FILE *out = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> hashfile[<span class="number">512</span>];</span><br><span class="line">	node tmp, p;</span><br><span class="line">	<span class="type">int</span> i, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r正在合并 %s\n\n&quot;</span>, result);</span><br><span class="line">	out = <span class="built_in">fopen</span>(result, <span class="string">&quot;wt&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (out == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;FILE_NUM; i++) file[i] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;FILE_NUM; i++)		<span class="comment">// 打开全部哈希文件</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(hashfile, <span class="string">&quot;%s\\hash_%d.~tmp&quot;</span>, tmpdir, i);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fileexist</span>(hashfile))</span><br><span class="line">		&#123;</span><br><span class="line">			file[i] = <span class="built_in">fopen</span>(hashfile, <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">			<span class="built_in">fscanf</span>(file[i], <span class="string">&quot;%d&quot;</span>, &amp;tmp.data);</span><br><span class="line">			tmp.id = i;</span><br><span class="line">			q.<span class="built_in">push</span>(tmp);		<span class="comment">// 初始化队列</span></span><br><span class="line">			count++;			<span class="comment">// 计数器</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r入队进度 %0.2f %%\t&quot;</span>, (count * <span class="number">100.0</span>) / FILE_NUM);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> s, e;</span><br><span class="line">	e = s = <span class="built_in">clock</span>();</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())		<span class="comment">// 开始 K 路归并</span></span><br><span class="line">	&#123;</span><br><span class="line">		tmp = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">// 将堆顶的元素写回磁盘, 再从磁盘中拿一个到内存</span></span><br><span class="line">		<span class="built_in">fprintf</span>(out, <span class="string">&quot;%d\n&quot;</span>, tmp.data);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fscanf</span>(file[tmp.id], <span class="string">&quot;%d&quot;</span>, &amp;p.data) != EOF)</span><br><span class="line">		&#123;</span><br><span class="line">			p.id = tmp.id;</span><br><span class="line">			q.<span class="built_in">push</span>(p);</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		e = <span class="built_in">clock</span>();			<span class="comment">// 计算进度</span></span><br><span class="line">		<span class="keyword">if</span> (e - s &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r处理进度 %0.2f %%\t&quot;</span>, (count * <span class="number">100.0</span>) / num);</span><br><span class="line">			s = e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;FILE_NUM; i++)</span><br><span class="line">		<span class="keyword">if</span> (file[i]) <span class="built_in">fclose</span>(file[i]);</span><br><span class="line">	<span class="built_in">fclose</span>(out);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">void</span>)</span>		<span class="comment">// 检查是否降序排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *in = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> max  = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r正在检查文件正确性...\n\n&quot;</span>);</span><br><span class="line">	in = <span class="built_in">fopen</span>(result, <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (in == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> s, e;</span><br><span class="line">	e = s = <span class="built_in">clock</span>();</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fscanf</span>(in, <span class="string">&quot;%d&quot;</span>, &amp;data) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (data &lt;= max) max = data;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fclose</span>(in);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		count++;</span><br><span class="line">		e = <span class="built_in">clock</span>();			<span class="comment">// 计算进度</span></span><br><span class="line">		<span class="keyword">if</span> (e - s &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r处理进度 %0.2f %%\t&quot;</span>, (count * <span class="number">100.0</span>) / num);</span><br><span class="line">			s = e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(in);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断文件存在</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fileexist</span><span class="params">(<span class="type">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	fp = <span class="built_in">fopen</span>(path, <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fclose</span>(fp);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> cmd_del[<span class="number">200</span>];		<span class="comment">// 删除目录</span></span><br><span class="line">	<span class="type">char</span> cmd_att[<span class="number">200</span>];		<span class="comment">// 设置隐藏</span></span><br><span class="line">	<span class="type">char</span> cmd_mkdir[<span class="number">200</span>];	<span class="comment">// 建立目录</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化 cmd 命令, 建立工作目录</span></span><br><span class="line">	<span class="built_in">sprintf</span>(cmd_del, <span class="string">&quot;rmdir /s /q %s&quot;</span>, tmpdir);</span><br><span class="line">	<span class="built_in">sprintf</span>(cmd_att, <span class="string">&quot;attrib +h %s&quot;</span>, tmpdir);</span><br><span class="line">	<span class="built_in">sprintf</span>(cmd_mkdir, <span class="string">&quot;mkdir %s&quot;</span>, tmpdir);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">access</span>(path, <span class="number">0</span>) == <span class="number">0</span>) <span class="built_in">system</span>(cmd_del);</span><br><span class="line">	<span class="built_in">system</span>(cmd_mkdir);		<span class="comment">// 建立工作目录</span></span><br><span class="line">	<span class="built_in">system</span>(cmd_att);		<span class="comment">// 隐藏目录</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 随机生成 2 亿个数字</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">write_file</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">map</span>();		<span class="comment">// 对 2 亿个数字进行哈希, 即 Map</span></span><br><span class="line">	<span class="built_in">calc</span>();		<span class="comment">// 对 300 个文件逐个排序</span></span><br><span class="line">	<span class="built_in">reduce</span>();	<span class="comment">// 最后将 300 个有序文件合并成一个文件, 即 reduce</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">check</span>()) <span class="built_in">printf</span>(<span class="string">&quot;\r排序正确!\t\t\t\n\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\r排序错误!\t\t\t\n\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(cmd_del);	<span class="comment">// 删除哈希文件</span></span><br><span class="line">	<span class="built_in">remove</span>(path);		<span class="comment">// 删除 2 亿数字文件</span></span><br><span class="line">	<span class="built_in">remove</span>(result);		<span class="comment">// 删除排序后的文件</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="位图思路"><a href="#位图思路" class="headerlink" title="位图思路"></a>位图思路</h3><p><strong>使用布隆过滤器（Bloom Filter）</strong>进行大数据量排序，也就是位运算在排序与搜索中的应用）</p>
<p>bit位操作 思考下面的问题: 一个最大的9位整数为999999999 这9亿条数据是不重复的，可不可以把这些数据组成一个队列或数组，让它有0~999999999(10亿个)元素数组下标表示数值，节点中用0表示这个数 没有，1表示有这个数，判断0或1只用一个bit存储就够了</p>
<p>声明一个可以包含9位整数的bit数组(10亿)，一共需要10亿&#x2F;8&#x3D;120M内存，把内存中的数据全部初始化为0 ，读取文件中的数据，并将数据放入内存。比如读到一个数据为341245909这个数据，那就先在内存中找到341245909这个bit，并将bit值 置为1 ，遍历整个bit数组，将bit为1的数组下标存入文件</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/06/epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kinnx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kinnx's Binary world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/06/epoll/" class="post-title-link" itemprop="url">epoll原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-06 19:13:14 / 修改时间：22:52:30" itemprop="dateCreated datePublished" datetime="2022-06-06T19:13:14+08:00">2022-06-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="从网卡接收数据说起"><a href="#从网卡接收数据说起" class="headerlink" title="从网卡接收数据说起"></a>从网卡接收数据说起</h3><p>下图是一个典型的计算机结构图，计算机由CPU、存储器（内存）、网络接口等部件组成。了解epoll本质的第一步，要从硬件的角度看计算机怎样接收网络数据。</p>
<p><img src="https://kinnx.xyz/i/2022/06/06/629df3e140110.png" alt="image-20220606203217658"></p>
<p>​                                   计算机结构图（图片来源：linux内核完全注释之微型计算机组成结构）</p>
<p>下图展示了网卡接收数据的过程。在①阶段，网卡收到网线传来的数据；经过②阶段的硬件电路的传输；最终将数据写入到内存中的某个地址上（③阶段）。这个过程涉及到DMA传输、IO通路选择等硬件有关的知识，但我们只需知道：<strong>网卡会把接收到的数据写入内存</strong>。</p>
<p><img src="https://kinnx.xyz/i/2022/06/06/629df43708c4f.png" alt="image-20220606203358673"></p>
<p>​																网卡接收数据的过程</p>
<p>通过硬件传输，网卡接收的数据存放到内存中。操作系统就可以去读取它们。</p>
<h3 id="如何知道接收了数据？"><a href="#如何知道接收了数据？" class="headerlink" title="如何知道接收了数据？"></a>如何知道接收了数据？</h3><p>了解epoll本质的第二步，要从<strong>CPU</strong>的角度来看数据接收。要理解这个问题，要先了解一个概念——中断。</p>
<p>计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时（电容可以保存少许电量，供CPU运行很短的一小段时间），它应立即去保存数据，保存数据的程序具有较高的优先级。</p>
<p>一般而言，由硬件产生的信号需要cpu立马做出回应（不然数据可能就丢失），所以它的优先级很高。cpu理应中断掉正在执行的程序，去做出响应；当cpu完成对硬件的响应后，再重新执行用户程序。中断的过程如下图，和函数调用差不多。只不过函数调用是事先定好位置，而中断的位置由“信号”决定。</p>
<p><img src="https://kinnx.xyz/i/2022/06/06/629df6b46db2f.png" alt="image-20220606204436088"></p>
<p>以键盘为例，当用户按下键盘某个按键时，键盘会给cpu的中断引脚发出一个高电平。cpu能够捕获这个信号，然后执行键盘中断程序。下图展示了各种硬件通过中断与cpu交互。</p>
<p><img src="https://kinnx.xyz/i/2022/06/06/629df6ed979b4.png" alt="image-20220606204533342"></p>
<p>现在可以回答本节提出的问题了：当网卡把数据写入到内存后，<strong>网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来</strong>，再通过网卡<strong>中断程序</strong>去处理数据。</p>
<h3 id="进程阻塞为什么不占用cpu资源？"><a href="#进程阻塞为什么不占用cpu资源？" class="headerlink" title="进程阻塞为什么不占用cpu资源？"></a>进程阻塞为什么不占用cpu资源？</h3><p>了解epoll本质的第三步，要从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件（如接收到网络数据）发生之前的等待状态，recv、select和epoll都是阻塞方法。<strong>了解“进程阻塞为什么不占用cpu资源？”，也就能够了解这一步。</strong></p>
<p>为简单起见，我们从普通的recv接收开始分析，先看看下面代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建socket</span></span><br><span class="line">SOCKET sockSrv = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//绑定</span></span><br><span class="line"><span class="type">int</span> retVal = <span class="built_in">bind</span>(sockSrv, (SOCKADDR *)&amp;addrSrv, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line"><span class="comment">//监听，同时能接收10个链接</span></span><br><span class="line"><span class="built_in">listen</span>(sockSrv, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//接受客户端连接</span></span><br><span class="line">SOCKET sockConn = <span class="built_in">accept</span>(sockSrv, (SOCKADDR *)&amp;addrCli, &amp;len);</span><br><span class="line"><span class="comment">//接收客户端数据</span></span><br><span class="line"><span class="built_in">recv</span>(sockConn, recvBuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//将数据打印出来printf(...)</span></span><br></pre></td></tr></table></figure>

<p>这是一段最基础的网络编程代码，先新建socket对象，依次调用bind、listen、accept，最后调用recv接收数据。recv是个阻塞方法，当程序运行到recv时，它会一直等待，直到接收到数据才往下执行。</p>
<p>那么阻塞的原理是什么？</p>
<h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。运行状态是进程获得cpu使用权，正在执行代码的状态；等待状态是阻塞状态，比如上述程序运行到recv时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p>
<p>下图中的计算机中运行着A、B、C三个进程，其中进程A执行着上述基础网络程序，一开始，这3个进程都被操作系统的工作队列所引用，处于运行状态，会分时执行。</p>
<p><img src="https://kinnx.xyz/i/2022/06/06/629df9556c723.png" alt="image-20220606205549107"></p>
<p>工作队列中有A、B和C三个进程</p>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>当进程A执行到创建socket的语句时，操作系统会创建一个由文件系统管理的socket对象（如下图）。这个socket对象包含了发送缓冲区、接收缓冲区、等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该socket事件的进程。</p>
<p><img src="https://kinnx.xyz/i/2022/06/06/629df961dc470.png" alt="image-20220606205601602"></p>
<p>当程序执行到recv时，操作系统会将进程A从工作队列移动到该socket的等待队列中（如下图）。由于工作队列只剩下了进程B和C，依据进程调度，cpu会轮流执行这两个进程的程序，不会执行进程A的程序。<strong>所以进程A被阻塞，不会往下执行代码，也不会占用cpu资源。</strong></p>
<p><img src="https://kinnx.xyz/i/2022/06/06/629df96ce0ba2.png" alt="image-20220606205612628"></p>
<p>ps：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。</p>
<h4 id="唤醒进程"><a href="#唤醒进程" class="headerlink" title="唤醒进程"></a>唤醒进程</h4><p>当socket接收到数据后，操作系统将该socket等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。也由于socket的接收缓冲区已经有了数据，recv可以返回接收到的数据。</p>
<h3 id="内核接收网络数据全过程"><a href="#内核接收网络数据全过程" class="headerlink" title="内核接收网络数据全过程"></a>内核接收网络数据全过程</h3><p><strong>这一步，贯穿网卡、中断、进程调度的知识，叙述阻塞recv下，内核接收数据全过程。</strong></p>
<p>如下图所示，进程在recv阻塞期间</p>
<p>（步骤①）计算机收到了对端传送的数据</p>
<p>（步骤②）数据经由网卡传送到内存</p>
<p>（步骤③）然后网卡通过中断信号通知cpu有数据到达，cpu执行中断程序</p>
<p>（步骤④）此处的中断程序主要有两项功能，先将网络数据写入到对应socket的接收缓冲区里面</p>
<p>（步骤⑤）再唤醒进程A</p>
<p>（步骤⑥）重新将进程A放入工作队列中。</p>
<p><img src="https://kinnx.xyz/i/2022/06/06/629dfb2bce6f1.png" alt="image-20220606210339517"></p>
<p>唤醒进程的过程如下图所示。</p>
<p><img src="https://kinnx.xyz/i/2022/06/06/629dfb3dc0e38.png" alt="image-20220606210357481"></p>
<p><strong>以上是内核接收数据全过程</strong></p>
<p>这里留有两个思考题，大家先想一想。</p>
<p>其一，操作系统如何知道网络数据对应于哪个socket？</p>
<p>其二，如何同时监视多个socket的数据？</p>
<p>（——我是分割线，想好了才能往下看哦~）</p>
<p>公布答案的时刻到了。</p>
<p>第一个问题：因为一个socket对应着一个端口号，而网络数据包中包含了ip和端口的信息，内核可以通过端口号找到对应的socket。当然，为了提高处理速度，操作系统会维护端口号到socket的索引结构，以快速读取。</p>
<p>第二个问题是<strong>多路复用的重中之重</strong>，是本文后半部分的重点！</p>
<h3 id="同时监视多个socket的简单方法"><a href="#同时监视多个socket的简单方法" class="headerlink" title="同时监视多个socket的简单方法"></a>同时监视多个socket的简单方法</h3><p>服务端需要管理多个客户端连接，而recv只能监视单个socket，这种矛盾下，人们开始寻找监视多个socket的方法。epoll的要义是高效的监视多个socket。从历史发展角度看，必然先出现一种不太高效的方法，人们再加以改进。只有先理解了不太高效的方法，才能够理解epoll的本质。</p>
<p>假如能够预先传入一个socket列表，<strong>如果列表中的socket都没有数据，挂起进程，直到有一个socket收到数据，唤醒进程</strong>。这种方法很直接，也是select的设计思想。</p>
<p>为方便理解，我们先复习select的用法。在如下的代码中，先准备一个数组（下面代码中的fds），让fds存放着所有需要监视的socket。然后调用select，如果fds中的所有socket都没有数据，select会阻塞，直到有一个socket接收到数据，select返回，唤醒进程。用户可以遍历fds，通过FD_ISSET判断具体哪个socket收到数据，然后做出处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">bind</span>(s, ...);</span><br><span class="line"><span class="built_in">listen</span>(s, ...);</span><br><span class="line"><span class="type">int</span> fds[] = 存放需要监听的socket</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">select</span>(..., fds, ...)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; fds.count; i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(fds[i], ...))&#123;</span><br><span class="line"> 	<span class="comment">//fds[i]的数据处理</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>select的流程</strong></p>
<p>select的实现思路很直接。假如程序同时监视如下图的sock1、sock2和sock3三个socket，那么在调用select之后，操作系统把进程A分别加入这三个socket的等待队列中。</p>
<p><img src="https://kinnx.xyz/i/2022/06/06/629dfe04c5a90.png" alt="image-20220606211548473"></p>
<p>当任何一个socket收到数据后，中断程序将唤起进程。下图展示了sock2接收到了数据的处理流程。</p>
<p>ps：recv和select的中断回调可以设置成不同的内容。</p>
<p><img src="https://kinnx.xyz/i/2022/06/06/629dfec923180.png" alt="image-20220606211904832"></p>
<p>所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面。如下图所示。</p>
<p><img src="https://kinnx.xyz/i/2022/06/06/629dfed937ad3.png" alt="image-20220606211920910"></p>
<p>经由这些步骤，当进程A被唤醒后，它知道至少有一个socket接收了数据。程序只需遍历一遍socket列表，就可以得到就绪的socket。</p>
<p>这种简单方式行之有效，在几乎所有操作系统都有对应的实现。</p>
<p>但是简单的方法往往有缺点，主要是：</p>
<p>①  每次调用select都需要将进程加入到所有监视socket的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个fds列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定select的最大监视数量，默认只能监视1024个socket。</p>
<p>②  进程被唤醒后，程序并不知道哪些socket收到数据，还需要遍历一次。</p>
<p>那么，有没有减少遍历的方法？有没有保存就绪socket的方法？这两个问题便是epoll技术要解决的。</p>
<p>补充说明：本节只解释了select的一种情形。当程序调用select时，内核会先遍历一遍socket，如果有一个以上的socket接收缓冲区有数据，那么select直接返回，不会阻塞。这也是为什么select的返回值有可能大于1的原因之一。如果没有socket有数据，进程才会阻塞。</p>
<h3 id="epoll的设计思路"><a href="#epoll的设计思路" class="headerlink" title="epoll的设计思路"></a>epoll的设计思路</h3><p>epoll是在select出现N多年后才被发明的，是select和poll的增强版本。epoll通过以下一些措施来改进效率。</p>
<h4 id="措施一：功能分离"><a href="#措施一：功能分离" class="headerlink" title="措施一：功能分离"></a><strong>措施一：功能分离</strong></h4><p>select低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。如下图所示，每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket相对固定，并不需要每次都修改。epoll将这两个操作分开，先用epoll_ctl维护等待队列，再调用epoll_wait阻塞进程。显而易见的，效率就能得到提升。</p>
<img src="https://kinnx.xyz/i/2022/06/06/629e010290282.png" alt="image-20220606212834211" style="zoom:67%;" />

<p>为方便理解后续的内容，我们先复习下epoll的用法。如下的代码中，先用epoll_create创建一个epoll对象epfd，再通过epoll_ctl将需要监视的socket添加到epfd中，最后调用epoll_wait等待数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">bind</span>(s, ...);</span><br><span class="line"><span class="built_in">listen</span>(s, ...);</span><br><span class="line"><span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(...);</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> <span class="type">int</span> n = <span class="built_in">epoll_wait</span>(...)</span><br><span class="line"> <span class="keyword">for</span>(接收到数据的socket)&#123;</span><br><span class="line"> <span class="comment">//处理</span></span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>功能分离，使得epoll有了优化的可能。</p>
<h4 id="措施二：就绪列表"><a href="#措施二：就绪列表" class="headerlink" title="措施二：就绪列表"></a><strong>措施二：就绪列表</strong></h4><p>select低效的另一个原因在于程序不知道哪些socket收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的socket，就能避免遍历。如下图所示，计算机共有三个socket，收到数据的sock2和sock3被rdlist（就绪列表）所引用。当进程被唤醒后，只要获取rdlist的内容，就能够知道哪些socket收到数据。</p>
<img src="https://kinnx.xyz/i/2022/06/06/629e02700af3f.png" alt="image-20220606213439703" style="zoom:80%;" />

<h3 id="epoll的原理和流程"><a href="#epoll的原理和流程" class="headerlink" title="epoll的原理和流程"></a>epoll的原理和流程</h3><p>本节会以示例和图表来讲解epoll的原理和流程。</p>
<h4 id="创建epoll对象"><a href="#创建epoll对象" class="headerlink" title="创建epoll对象"></a><strong>创建epoll对象</strong></h4><p>如下图所示，当某个进程调用epoll_create方法时，内核会创建一个eventpoll对象（也就是程序中epfd所代表的对象）。eventpoll对象也是文件系统中的一员，和socket一样，它也会有等待队列。</p>
<img src="https://kinnx.xyz/i/2022/06/06/629e02a342e47.png" alt="image-20220606213530935" style="zoom:80%;" />

<p>创建一个代表该epoll的eventpoll对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为eventpoll的成员。</p>
<h4 id="维护监视列表"><a href="#维护监视列表" class="headerlink" title="维护监视列表"></a><strong>维护监视列表</strong></h4><p>创建epoll对象后，可以用epoll_ctl添加或删除所要监听的socket。以添加socket为例，如下图，如果通过epoll_ctl添加sock1、sock2和sock3的监视，内核会将eventpoll添加到这三个socket的等待队列中。</p>
<img src="https://kinnx.xyz/i/2022/06/06/629e0320da8dd.png" alt="image-20220606213736545" style="zoom:80%;" />

<p>当socket收到数据后，中断程序会操作eventpoll对象，而不是直接操作进程。</p>
<h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a><strong>接收数据</strong></h4><p>当socket收到数据后，中断程序会给eventpoll的“就绪列表”添加socket引用。如下图展示的是sock2和sock3收到数据后，中断程序让rdlist引用这两个socket。</p>
<img src="https://kinnx.xyz/i/2022/06/06/629e03308aa65.png" alt="image-20220606213752232" style="zoom:80%;" />

<p>eventpoll对象相当于是socket和进程之间的中介，socket的数据接收并不直接影响进程，而是通过改变eventpoll的就绪列表来改变进程状态。</p>
<p>当程序执行到epoll_wait时，如果rdlist已经引用了socket，那么epoll_wait直接返回，如果rdlist为空，阻塞进程。</p>
<h4 id="阻塞和唤醒进程"><a href="#阻塞和唤醒进程" class="headerlink" title="阻塞和唤醒进程"></a><strong>阻塞和唤醒进程</strong></h4><p>假设计算机中正在运行进程A和进程B，在某时刻进程A运行到了epoll_wait语句。如下图所示，内核会将进程A放入eventpoll的等待队列中，阻塞进程。</p>
<img src="https://kinnx.xyz/i/2022/06/06/629e037feb4ba.png" alt="image-20220606213911229" style="zoom:80%;" />

<p>当socket接收到数据，中断程序一方面修改rdlist，另一方面唤醒eventpoll等待队列中的进程，进程A再次进入运行状态（如下图）。也因为rdlist的存在，进程A可以知道哪些socket发生了变化。</p>
<img src="https://kinnx.xyz/i/2022/06/06/629e0387a787e.png" alt="image-20220606213919341" style="zoom:80%;" />

<h3 id="epoll的数据结构"><a href="#epoll的数据结构" class="headerlink" title="epoll的数据结构"></a>epoll的数据结构</h3><p>如下图所示，eventpoll包含了。。等成员</p>
<p>wq：等待队列链表。软中断数据就绪的时候会通过wq来找到阻塞在epoll对象上的用户进程。</p>
<p>rbr：一棵红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll内部使用了一棵红黑树。通过这棵树来管理用户进程下添加进来的所有socket连接。</p>
<p>rdllist：就绪的描述符的链表。当有的连接就绪的时候，内核会把就绪的连接放到rdllist链表里。这样应用进程只需要判断链表就能找出就绪进程，而不用去遍历整棵树。</p>
<p><strong>就绪列表的数据结构</strong></p>
<p>就绪列表引用着<strong>就绪</strong>的socket，所以它应能够快速的插入数据。</p>
<p>程序可能随时调用epoll_ctl添加监视socket，也可能随时删除。当删除时，若该socket已经存放在就绪列表中，它也应该被移除。</p>
<p>所以就绪列表应是一种能够快速插入和删除的数据结构。双向链表就是这样一种数据结构，epoll使用双向链表来实现就绪队列（对应上图的rdllist）。</p>
<p><strong>索引结构</strong></p>
<p>既然epoll将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的socket。至少要方便的添加和移除，还要便于搜索，以避免重复添加。红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是O(log(N))，效率较好。epoll使用了红黑树作为索引结构（对应上图的rbr）。</p>
<p>ps：因为操作系统要兼顾多种功能，以及由更多需要保存的数据，rdlist并非直接引用socket，而是通过<strong>epitem</strong>(红黑树节点对象）间接引用。</p>
<h3 id="一图总结epoll工作流程"><a href="#一图总结epoll工作流程" class="headerlink" title="一图总结epoll工作流程"></a>一图总结epoll工作流程</h3><p><img src="https://kinnx.xyz/i/2022/06/06/629e1482b1669.png" alt="image-20220606225146111"></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/361750240">https://zhuanlan.zhihu.com/p/361750240</a> 万字长文epoll具体实施细节</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/31/assert/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kinnx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kinnx's Binary world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/31/assert/" class="post-title-link" itemprop="url">assert</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-31 22:28:24 / 修改时间：22:45:50" itemprop="dateCreated datePublished" datetime="2022-05-31T22:28:24+08:00">2022-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/31/muduo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kinnx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kinnx's Binary world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/31/muduo/" class="post-title-link" itemprop="url">muduo网络库（c++11源码剖析）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-31 12:58:20 / 修改时间：19:03:29" itemprop="dateCreated datePublished" datetime="2022-05-31T12:58:20+08:00">2022-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><h3 id="涉及到的关键类"><a href="#涉及到的关键类" class="headerlink" title="涉及到的关键类:"></a>涉及到的关键类:</h3><p>​       <code>EventLoop</code>：事件循环核心类，遵循<strong>per thread one loop</strong>的思想，一个线程一个事件循环，在循环中用IO多路复用，分发IO事件。</p>
<p><code>EventLoopThread</code>:封装了std::thread，可以启动一个线程，并执行EventLoop的循环。</p>
<p><code>EventLoopThreadPoll</code>:用于管理EventLoopThread的线程池，启动线程，结束线程，可以将获取的任务分派到执行                         EventLoop的线程里。</p>
<p><code>TcpServer</code>:服务端，负责接受处理新连接，有线程池和接受Acceptor的控制权。</p>
<p><code>Acceptor</code>:含有服务端socket信息，并能处理接受事件，回调给TcpServer对象。</p>
<p>​    	</p>
<p><code>TcpConnection</code>:一个连接对应一个TcpConnection，内部也置有channel_，处理收事件和读事件。</p>
<p>​    	</p>
<p><code>Channel</code>:每个连接都会对应一个Channel，IO的注册和响应事件都通过Channel回调反馈给其他对象。</p>
<p>结构图：</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/6295a1368c926.png" alt="image-20220531130139932"></p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>​       上图中空心菱形代表聚合关系,实心菱形代表组合关系。如果muduo作为库使用的话白色的UML作为暴露给用户的接口，灰色的代表内部实现，当然我们这里的版本肯定是要对整个结构进行分析。这篇博文关系服务端的设计，暂不讨论Connector和TcpClient这两个类。我简单说下流程，</p>
<p>​       首先，<code>TcpServer</code>中会有一个<code>Acceptor</code>对象来绑定监听服务端Socket，而<code>Acceptor</code>中会单独有一个<code>Channel</code>专门负责处理接受事件，回调给<code>TcpServer</code>创建新连接。一个新连接生成一个TcpConnection,并将从线程池中通过一定的负载均衡算法获取到的某个线程的<code>EventLoop</code>传入<code>TcpConnection</code>构造函数。在<code>TcpConnection</code>中生成新通道Channel并传入对应<code>TcpConnection</code>的<code>EventLoop</code>中去，到此连接事件处理完毕。</p>
<p>​       之后，每个线程中的每个EventLoop会调用IO多路复用(select、poll、epoll)来检测socket上客户端事件，一旦侦听到，每个活动Channel会回调给TcpConnect读出Buff，再回调给我们的业务类，同样的类似的handleClose()用于处理断开连接操作。</p>
<p>​      对于写事件是通过我们业务层的Session，内部的TcpConnection对象发送给对端。</p>
<p>​      到此，整个流程基本就是这样。</p>
<h2 id="EventLoopThreadPool类"><a href="#EventLoopThreadPool类" class="headerlink" title="EventLoopThreadPool类"></a>EventLoopThreadPool类</h2><p>​	EventLoop线程的线程池，该类负责对线程创建，结束，可以round-robin轮询或者哈希的方式获取线程，当然也可以扩展其他负载均衡的方法。在TcpServer类中有该实例对象，生命周期和TcpServer绑定。</p>
<h3 id="成员变量-："><a href="#成员变量-：" class="headerlink" title="成员变量 ："></a>成员变量 ：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop*                                      baseLoop_; 		<span class="comment">//主线程的EventLoop</span></span><br><span class="line">	std::string                                     name_;			<span class="comment">//名称标记</span></span><br><span class="line">	<span class="type">bool</span>                                            started_;		<span class="comment">//线程池开启时标志位</span></span><br><span class="line">	<span class="type">int</span>                                             numThreads_;	<span class="comment">//线程总数量</span></span><br><span class="line">	<span class="type">int</span>                                             next_;			<span class="comment">//当前对外传递的线程号</span></span><br><span class="line">	std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt; &gt;  threads_;		<span class="comment">//线程集合vector指针</span></span><br><span class="line">	std::vector&lt;EventLoop*&gt;                         loops_;			<span class="comment">//循环类事件指针</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	首先成员变量: baseLoop_是主线程的EventLoop，name_是名称标记，started_是线程池开启时标志位，numThreads是设置的线程总数量，next_是标记当前传递给外面的是第几个线程，threads_是线程集合vector指针，loops是循环类事件指针。</p>
<h3 id="重要函数及作用："><a href="#重要函数及作用：" class="headerlink" title="重要函数及作用："></a><strong>重要函数及作用：</strong></h3><p><strong>初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThreadPool::init</span><span class="params">(EventLoop* baseLoop, <span class="type">int</span> numThreads)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    numThreads_ = numThreads;</span><br><span class="line">    baseLoop_ = baseLoop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	初始化传入主线程的循环类以及创建的线程总数量。</p>
<p><strong>线程池启动</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThreadPool::start</span><span class="params">(<span class="type">const</span> ThreadInitCallback&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//assert(baseLoop_);</span></span><br><span class="line">    <span class="keyword">if</span> (baseLoop_ == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//assert(!started_);</span></span><br><span class="line">    <span class="keyword">if</span> (started_)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    baseLoop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;%s%d&quot;</span>, name_.<span class="built_in">c_str</span>(), i);</span><br><span class="line">        <span class="function">std::unique_ptr&lt;EventLoopThread&gt; <span class="title">t</span><span class="params">(<span class="keyword">new</span> EventLoopThread(cb, buf))</span></span>;</span><br><span class="line">        <span class="comment">//EventLoopThread* t = new EventLoopThread(cb, buf);</span></span><br><span class="line">		<span class="comment">//每个线程放入容器管理</span></span><br><span class="line">        loops_.<span class="built_in">push_back</span>(t-&gt;<span class="built_in">startLoop</span>());</span><br><span class="line">        threads_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numThreads_ == <span class="number">0</span> &amp;&amp; cb)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//如果创建的线程为0, 则执行cb（baseLoop_）;</span></span><br><span class="line">        <span class="built_in">cb</span>(baseLoop_);<span class="comment">//不需要建立IOThread</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	baseLoop_-&gt;assertInLoopThread();判断当前是不是在主线程创建，如果不是，退出程序。之后在循环中创建线程传入名称和线程序号以及回调函数，用内部容器将指针管理起来。cb这个回调函数我暂时没看明白作用是什么，之后问问大佬，再回来更新。</p>
<p><strong>线程池结束</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThreadPool::stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : threads_)</span><br><span class="line">    &#123;</span><br><span class="line">        iter-&gt;<span class="built_in">stopLoop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	遍历每个线程结束eventloop,并且用join结束线程。</p>
<p><strong>连接到来时用轮询方式获取线程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoop* <span class="title">EventLoopThreadPool::getNextLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    baseLoop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="comment">//assert(started_);</span></span><br><span class="line">    <span class="keyword">if</span> (!started_)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">EventLoop* loop = baseLoop_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!loops_.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//round-robin --负载均衡</span></span><br><span class="line">    loop = loops_[next_];</span><br><span class="line">    ++next_;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">implicit_cast</span>&lt;<span class="type">size_t</span>&gt;(next_)&gt;=loops_.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        next_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	用轮询方式获取新线程，next做标记，分配一个线程，next加1 ,按顺序分配线程。当没有生成其他io线程时，返回主线程给外部。</p>
<h2 id="EventLoopThread类："><a href="#EventLoopThread类：" class="headerlink" title="EventLoopThread类："></a>EventLoopThread类：</h2><p>线程池中分配的线程类，内部是使用std::thread，每个线程持有一个自己的EventLoop。</p>
<h3 id="类成员变量-："><a href="#类成员变量-：" class="headerlink" title="类成员变量 ："></a><strong>类成员变量 ：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop*                     loop_;</span><br><span class="line">	<span class="type">bool</span>                           exiting_;</span><br><span class="line">	std::unique_ptr&lt;std::thread&gt;   thread_;</span><br><span class="line">	std::mutex                     mutex_;</span><br><span class="line">	std::condition_variable        cond_;         <span class="comment">//条件变量</span></span><br><span class="line">	ThreadInitCallback             callback_;</span><br></pre></td></tr></table></figure>

<p>​	loop就是每个线程持有的一个循环，exiting是线程退出标志位。thread、mutex、cond大家比较熟悉，是线程类和基本的线程同步的原语。callback_是线程初始化回调。</p>
<h3 id="重要函数及作用：-1"><a href="#重要函数及作用：-1" class="headerlink" title="重要函数及作用："></a>重要函数及作用：</h3><p><strong>初始化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventLoopThread::EventLoopThread(const ThreadInitCallback&amp; cb,</span><br><span class="line">								 const std::string&amp; name/* = &quot;&quot;*/)</span><br><span class="line">								 : loop_(NULL),</span><br><span class="line">								 exiting_(false),</span><br><span class="line">								 callback_(cb)//callback_</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		生命周期由EventLoopThreadPoll控制,没有特别的初始化函数，构造函数中传入自定义回调函数以及线程池中线程的名称以及序号字符。</p>
<p><strong>开启线程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoop* <span class="title">EventLoopThread::startLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//assert(!thread_.started());</span></span><br><span class="line">	<span class="comment">//thread_.start();</span></span><br><span class="line">	thread_.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;EventLoopThread::threadFunc, <span class="keyword">this</span>)));</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (loop_ == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cond_.<span class="built_in">wait</span>(lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> loop_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EventLoop loop;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (callback_)  </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">callback_</span>(&amp;loop);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//一个一个的线程创建</span></span><br><span class="line">	    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">		loop_ = &amp;loop;</span><br><span class="line">		cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	loop.<span class="built_in">loop</span>();</span><br><span class="line">	<span class="comment">//assert(exiting_);</span></span><br><span class="line">	loop_ = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	可以看到在startloop中线程创建了线程，之后在while(loop&#x3D;&#x3D;NULL)判断中用条件变量使线程休眠。在threadFunc()函数中在栈上创建了一个EventLoop对象，在callback回调中可以自定义一些信息告诉线程池，用类内部的loop指针指向栈上的loop对象，释放条件变量，唤醒主线程，启动loop循环。</p>
<p><strong>结束线程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::stopLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loop_ != <span class="literal">NULL</span>)</span><br><span class="line">        loop_-&gt;<span class="built_in">quit</span>();</span><br><span class="line"></span><br><span class="line">    thread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文中的QEventLoopThreadPool调用的是这里的函数，结束线程常规操作，loop-&gt;quit退出线程函数,join结束销毁线程。</p>
<h2 id="EventLoop设计"><a href="#EventLoop设计" class="headerlink" title="EventLoop设计"></a>EventLoop设计</h2><p>​	负责处理事件循环的关键类，遵循one loop per thread原则，所以一个线程中只有一个EventLoop对象，通过loop进入事件循环(while循环)，在循环中主要有四个作用，按顺序是处理定时器事件，IO多路复用检测，处理检测返回的活动通道事件，处理自己的额外消息事件。one loop per thread已经是几乎所有网络库通用技术，需要深刻理解。</p>
<h3 id="成员变量："><a href="#成员变量：" class="headerlink" title="成员变量："></a>成员变量：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">typedef</span> std::vector&lt;Channel*&gt; ChannelList;</span><br><span class="line">		<span class="type">bool</span>                                looping_;</span><br><span class="line">		<span class="type">bool</span>                                quit_;</span><br><span class="line">		<span class="type">bool</span>                                eventHandling_; </span><br><span class="line">		<span class="type">bool</span>                                callingPendingFunctors_;</span><br><span class="line">		<span class="type">const</span> std::thread::id               threadId_;</span><br><span class="line">		Timestamp                           pollReturnTime_;  </span><br><span class="line">		std::unique_ptr&lt;Poller&gt;             poller_;          </span><br><span class="line">        std::unique_ptr&lt;TimerQueue&gt;         timerQueue_;</span><br><span class="line">        <span class="type">int64_t</span>                             iteration_;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">                SOCKET                              wakeupFdSend_;</span><br><span class="line">                SOCKET                              wakeupFdListen_;</span><br><span class="line">                SOCKET                              wakeupFdRecv_;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                SOCKET                              wakeupFd_;          </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		std::unique_ptr&lt;Channel&gt;            wakeupChannel_;</span><br><span class="line">		ChannelList                         activeChannels_;</span><br><span class="line">		Channel*                            currentActiveChannel_;</span><br><span class="line">		std::mutex                          mutex_;</span><br><span class="line">		std::vector&lt;Functor&gt;                pendingFunctors_; </span><br><span class="line">		Functor                             frameFunctor_;</span><br></pre></td></tr></table></figure>

<p>​	成员变量比较多，先简单讲下，下面将具体功能还会再讲一遍，looping是循环开启的标志位，quit是退出循环标志位，eventHandling_是正在处理IO事件标志位，callingPendingFunctors_是正在处理其他事件标志位，threadId是创建EventLoop的线程Id，pollReturnTime_是多路复用返回时间戳，poller_是封装IO多路复用的类，timerQueue是处理一些事件定时器队列，wakeup的三个socket是在windows下，该类给自己发送消息唤醒loop的Io复用，处理设置其他的事件，同样wakeupFd_是linux下的接口，wakeupChannel是处理自己事件的Channel，activeChannels是IO复用检测返回的活动通道集合，currentActiveChannel_是正在处理消息的Channel,pendingFunctors是自己设置的额外的处理函数集合。</p>
<h3 id="重要函数及作用：-2"><a href="#重要函数及作用：-2" class="headerlink" title="重要函数及作用："></a>重要函数及作用：</h3><p><strong>构造函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">EventLoop::<span class="built_in">EventLoop</span>()</span><br><span class="line">    :<span class="built_in">looping_</span>(<span class="literal">false</span>),</span><br><span class="line">    <span class="built_in">quit_</span>(<span class="literal">false</span>),</span><br><span class="line">    <span class="built_in">eventHandling_</span>(<span class="literal">false</span>),</span><br><span class="line">    <span class="built_in">callingPendingFunctors_</span>(<span class="literal">false</span>),</span><br><span class="line">    <span class="built_in">threadId_</span>(std::this_thread::<span class="built_in">get_id</span>()),</span><br><span class="line">    <span class="built_in">timerQueue_</span>(<span class="keyword">new</span> <span class="built_in">TimerQueue</span>(<span class="keyword">this</span>)),</span><br><span class="line">    <span class="built_in">iteration_</span>(<span class="number">0L</span>),</span><br><span class="line">    <span class="built_in">currentActiveChannel_</span>(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">createWakeupfd</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    wakeupChannel_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(<span class="keyword">this</span>, wakeupFdSend_)); <span class="comment">//传入连接的socket</span></span><br><span class="line">    poller_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">SelectPoller</span>(<span class="keyword">this</span>));<span class="comment">//Select模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    wakeupChannel_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(<span class="keyword">this</span>, wakeupFd_));</span><br><span class="line">    poller_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">EPollPoller</span>(<span class="keyword">this</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t_loopInThisThread)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOGF</span>(<span class="string">&quot;Another EventLoop  exists in this thread &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t_loopInThisThread = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;EventLoop::handleRead, <span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// we are always reading the wakeupfd</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">enableReading</span>();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//std::stringstream ss;	</span></span><br><span class="line">    <span class="comment">//ss &lt;&lt; &quot;eventloop create threadid = &quot; &lt;&lt; threadId_;</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; ss.str() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	EventLoop是在线程池分配的某一个线程中创建出来，不需要传入参数，在构造函数初始化列表中完成一些变量的初始化。我们可以看到函数体内主要的是创建了三个fd（linux只需要一个Fd）以及用一个活动通道注册他们，他们的作用我会在下面讲。我们还看到了一个plloer，这是封装了IO多路复用(selelct,poll,epoll)的类。</p>
<p><strong>关键函数处理事件：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//assert(!looping_);</span></span><br><span class="line">	<span class="comment">//事件循环必须在io线程执行 如果不在代表发生错误，直接退出程序。</span></span><br><span class="line">	<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>;  <span class="comment">// <span class="doctag">FIXME:</span> what if someone calls quit() before loop() ?</span></span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;EventLoop 0x%x  start looping&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!quit_)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//定时器检测</span></span><br><span class="line">        timerQueue_-&gt;<span class="built_in">doTimer</span>();</span><br><span class="line">        activeChannels_.<span class="built_in">clear</span>();</span><br><span class="line">     </span><br><span class="line">    	<span class="comment">//调用poll返回活动的通道，有可能是唤醒返回的</span></span><br><span class="line">        pollReturnTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">        <span class="comment">//if (Logger::logLevel() &lt;= Logger::TRACE)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="built_in">printActiveChannels</span>(); <span class="comment">//打印下来</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        ++iteration_;</span><br><span class="line">        <span class="comment">// TODO sort channel by priority</span></span><br><span class="line">        eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it : activeChannels_)</span><br><span class="line">        &#123;</span><br><span class="line">            currentActiveChannel_ = it;</span><br><span class="line">            currentActiveChannel_-&gt;<span class="built_in">handleEvent</span>(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line">        currentActiveChannel_ = <span class="literal">nullptr</span>;</span><br><span class="line">        eventHandling_ = <span class="literal">false</span>;</span><br><span class="line">     </span><br><span class="line">    	<span class="comment">//这种设计使得IO线程也能执行一些计算任务，避免了IO线程在不忙时长期阻塞在IO multiplexing调用中</span></span><br><span class="line">        <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (frameFunctor_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">frameFunctor_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;EventLoop 0x%0x stop looping&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">     </span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">    std::string stid = oss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">&quot;Exiting loop, EventLoop object: 0x%x , threadID: %s&quot;</span>, <span class="keyword">this</span>, stid.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是one loop per thread关键的函数了，可以看到实际上可以拆为四个作用，doTimer()处理定义的定时器事件，poll(kPollTimeMs, &amp;activeChannels_)是通过IO复用技术检测有事件的通道，handleEvent(pollReturnTime_)活动通道处理返回的各个事件，doPendingFunctors()处理额外的一些任务。定时器队列这里不讲，自己有兴趣可以去了解。我们看到poll返回了所有有事件的activeChannels,之后Channel处理这些IO事件，当是侦听socket时，最终调用Acceptor::handleRead，当是客户端socket时，调用TcpConnection::handleRead。然后doPendingFunctors可以处理其他一些任务，比如客户端A给给客户端B发送消息，这当然执行在接受客户端A然后创建Session的线程中，我们在A的线程中找到了B的TcpConnection，进而找到了B的EventLoop，然后将这个发送任务加入B线程任务队列，也就是需要执行doPendingFunctors，但是程序阻塞在了poll返回函数里，执行不到doPendingFunctors，那么怎么办？于是我们给之前创建的唤醒fd发消息，唤醒poll，进而通过dpPendingFunctor处理发送消息，这里就是刚才创建唤醒的fd的作用。</p>
<p><strong>给loop分派任务：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(<span class="type">const</span> Functor&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isInLoopThread</span>())<span class="comment">//如果是本线程，则直接运行，否则加入队列，等待运行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>();  <span class="comment">//等于accept::listen</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(<span class="type">const</span> Functor&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">push_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>() || callingPendingFunctors_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	和上面说的一样，外部通过runInloop给当前loop分配任务，在当前线程则直接执行，其他线程分到任务队列，然后唤醒fd，之后再处理。</p>
<p><strong>其他的对Channel操作：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//assert(channel-&gt;ownerLoop() == this);</span></span><br><span class="line">    <span class="keyword">if</span> (channel-&gt;<span class="built_in">ownerLoop</span>() != <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assertInLoopThread</span>();</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> poller_-&gt;<span class="built_in">updateChannel</span>(channel);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::removeChannel</span><span class="params">(Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//assert(channel-&gt;ownerLoop() == this);</span></span><br><span class="line">    <span class="keyword">if</span> (channel-&gt;<span class="built_in">ownerLoop</span>() != <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (eventHandling_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//assert(currentActiveChannel_ == channel || std::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;Remove channel, channel = 0x%x, fd = %d&quot;</span>, channel, channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    poller_-&gt;<span class="built_in">removeChannel</span>(channel);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EventLoop::hasChannel</span><span class="params">(Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//assert(channel-&gt;ownerLoop() == this);</span></span><br><span class="line">    <span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="keyword">return</span> poller_-&gt;<span class="built_in">hasChannel</span>(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Channel设计"><a href="#Channel设计" class="headerlink" title="Channel设计"></a>Channel设计</h2><p>​	Channel扮演了一个IO事件分发器的作用。主要有两个地方，一个是Acceptor中的Channel，主要处理连接事件，另外每个TcpConnection类中会有一个Channel，检测fd的刻可读，关闭，错误消息，触发相应的回调函数。生命周期由Acceptor和TcpConnection控制。</p>
<h3 id="成员变量：-1"><a href="#成员变量：-1" class="headerlink" title="成员变量："></a>成员变量：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span>            kNoneEvent;</span><br><span class="line">		<span class="type">static</span> <span class="type">const</span> <span class="type">int</span>            kReadEvent;</span><br><span class="line">		<span class="type">static</span> <span class="type">const</span> <span class="type">int</span>            kWriteEvent;</span><br><span class="line">		EventLoop*                  loop_;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span>                   fd_;</span><br><span class="line">		<span class="type">int</span>                         events_;</span><br><span class="line">		<span class="type">int</span>                         revents_; </span><br><span class="line">		<span class="type">int</span>                         index_; </span><br><span class="line">		<span class="type">bool</span>                        logHup_;</span><br><span class="line">		std::weak_ptr&lt;<span class="type">void</span>&gt;         tie_;         </span><br><span class="line">		<span class="type">bool</span>                        tied_;</span><br><span class="line">		<span class="comment">//bool                        eventHandling_;</span></span><br><span class="line">		<span class="comment">//bool                        addedToLoop_;</span></span><br><span class="line">		ReadEventCallback           readCallback_;</span><br><span class="line">		EventCallback               writeCallback_;</span><br><span class="line">		EventCallback               closeCallback_;</span><br><span class="line">		EventCallback               errorCallback_;</span><br></pre></td></tr></table></figure>

<p>​	kNoneEvent，KreadEvent，kWriteEvent是用于标记events_状态的值，loop是传入的所属的eventloop，fd_是创建通道时传入的文件描述符，events_是通道状态标记，revents_是多路复用检测后外部set的事件类型，tie用于延长对象的生命周期，readCallback,writeCallback,closeCallback,errorCallback则是注册的外部回调。</p>
<h3 id="重要函数及作用：-3"><a href="#重要函数及作用：-3" class="headerlink" title="重要函数及作用："></a>重要函数及作用：</h3><p><strong>创建</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Channel::<span class="built_in">Channel</span>(EventLoop* loop, <span class="type">int</span> fd__): <span class="built_in">loop_</span>(loop),</span><br><span class="line">                                            <span class="built_in">fd_</span>(fd__),</span><br><span class="line">                                            <span class="built_in">events_</span>(<span class="number">0</span>),</span><br><span class="line">                                            <span class="built_in">revents_</span>(<span class="number">0</span>),</span><br><span class="line">                                            <span class="built_in">index_</span>(<span class="number">-1</span>),</span><br><span class="line">                                            <span class="built_in">logHup_</span>(<span class="literal">true</span>),</span><br><span class="line">                                            <span class="built_in">tied_</span>(<span class="literal">false</span>)<span class="comment">/*,</span></span><br><span class="line"><span class="comment">                                            eventHandling_(false),</span></span><br><span class="line"><span class="comment">                                            addedToLoop_(false)</span></span><br><span class="line"><span class="comment">                                            */</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	因为一般网络库会把监听的scoket单独放在一个线程，然后连接到来的多个socket放在其他几个线程，所以就有了两个创建Channel的地方，一个是在Acceptor构造中创建用于监听socket的通道，一个是新连接到来TcpConnection中创建的Channel。构造函数中传入了当前所属的事件循环和文件fd。</p>
<p><strong>注册回调</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">channel_-&gt;<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">channel_-&gt;<span class="built_in">setWriteCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));</span><br><span class="line">channel_-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));</span><br><span class="line">channel_-&gt;<span class="built_in">setErrorCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleError, <span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>

<p>​	前面说了，两个地方创建了Channel，所以回调也设置也不同，Acceptor中Channel回调指向了Acceptor的handle函数，进而指向了TcpServer的newconnetion(),而TcpConnection中Channel则是回调到了TcpConnection中。</p>
<p><strong>处理事件</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEvent</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::shared_ptr&lt;<span class="type">void</span>&gt; guard;</span><br><span class="line">	<span class="keyword">if</span> (tied_)</span><br><span class="line">	&#123;</span><br><span class="line">		guard = tie_.<span class="built_in">lock</span>();</span><br><span class="line">		<span class="keyword">if</span> (guard)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">LOGD</span>(<span class="built_in">reventsToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">if</span> ((revents_ &amp; XPOLLHUP) &amp;&amp; !(revents_ &amp; XPOLLIN))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (logHup_)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">LOGW</span>(<span class="string">&quot;Channel::handle_event() XPOLLHUP&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (closeCallback_) <span class="built_in">closeCallback_</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (revents_ &amp; XPOLLNVAL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">LOGW</span>(<span class="string">&quot;Channel::handle_event() XPOLLNVAL&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">if</span> (revents_ &amp; (XPOLLERR | XPOLLNVAL))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (errorCallback_) </span><br><span class="line">	        <span class="built_in">errorCallback_</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (revents_ &amp; (XPOLLIN | XPOLLPRI | XPOLLRDHUP))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//当是侦听socket时，readCallback_指向Acceptor::handleRead</span></span><br><span class="line">	    <span class="comment">//当是客户端socket时，调用TcpConnection::handleRead </span></span><br><span class="line">	    <span class="keyword">if</span> (readCallback_) </span><br><span class="line">	        <span class="built_in">readCallback_</span>(receiveTime);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">if</span> (revents_ &amp; XPOLLOUT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果是连接状态服的socket，则writeCallback_指向Connector::handleWrite()</span></span><br><span class="line">	    <span class="keyword">if</span> (writeCallback_) </span><br><span class="line">	        <span class="built_in">writeCallback_</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//eventHandling_ = false;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	handleEvent中tie实际上这是一个弱指针，指向向他的拥有者TcpConnection，为什么要这么做呢？假如Channel正在处理事件，TcpConnection连接关闭销毁了，程序可能会dump，要保证TcpConnection不被销毁，因此Channel中存了一个TcpConnection的弱指针，在处理事件的时候，lock将引用计数加1保证TcpConnection不被销毁。</p>
<p>​	handleEventWithGuard根据revents_不同的值调用不同的回调函数，revents_的值是在Poll(IO多路复用类)设置的，由Poll检测是什么事件，给revents_赋相应的值，处理不同的事件。</p>
<h2 id="TcpConnection设计"><a href="#TcpConnection设计" class="headerlink" title="TcpConnection设计"></a>TcpConnection设计</h2><p>​	每接受到一个连接，就会创建一个TcpConnection，每个TcpConnection用shared指针保存在TcpServer中，处理的回调都经过该类，这里最需要注意的就是关于TcpConnection的生命周期。</p>
<h3 id="成员变量：-2"><a href="#成员变量：-2" class="headerlink" title="成员变量："></a>成员变量：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">		EventLoop*                  loop_;</span><br><span class="line">		<span class="type">const</span> string                name_;</span><br><span class="line">		StateE                      state_;</span><br><span class="line">		std::unique_ptr&lt;Socket&gt;     socket_;</span><br><span class="line">		std::unique_ptr&lt;Channel&gt;    channel_;</span><br><span class="line">		<span class="type">const</span> InetAddress           localAddr_;</span><br><span class="line">		<span class="type">const</span> InetAddress           peerAddr_;</span><br><span class="line">		ConnectionCallback          connectionCallback_;</span><br><span class="line">		MessageCallback             messageCallback_;</span><br><span class="line">		WriteCompleteCallback       writeCompleteCallback_;</span><br><span class="line">		HighWaterMarkCallback       highWaterMarkCallback_;</span><br><span class="line">		CloseCallback               closeCallback_;</span><br><span class="line">		<span class="type">size_t</span>                      highWaterMark_;</span><br><span class="line">		Buffer                      inputBuffer_;</span><br><span class="line">		Buffer                      outputBuffer_; </span><br><span class="line">loop是TcpConnection所在的循环，name是创建时传入的连接的一些信息，state_</span><br></pre></td></tr></table></figure>

<p>是TcpConnection当前状态机，有连接中，断开连接中，已连接和已断开4个状态，socket是传入的文件描述符，channel是创建的通道，里面含有一个TcpConnection的一个弱指针，适当的时候提升(Channel那期博客讲过)，localAddr和peerAddr是对端和本端的地址信息，接下来就是几个回调函数，最后是输入和输出缓冲区Buff。</p>
<h3 id="重要函数及作用：-4"><a href="#重要函数及作用：-4" class="headerlink" title="重要函数及作用："></a>重要函数及作用：</h3><p><strong>创建</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop* loop, <span class="type">const</span> string&amp; nameArg, <span class="type">int</span> sockfd, <span class="type">const</span> InetAddress&amp; localAddr, <span class="type">const</span> InetAddress&amp; peerAddr)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop),</span><br><span class="line">    <span class="built_in">name_</span>(nameArg),</span><br><span class="line">    <span class="built_in">state_</span>(kConnecting),</span><br><span class="line">    <span class="built_in">socket_</span>(<span class="keyword">new</span> <span class="built_in">Socket</span>(sockfd)),</span><br><span class="line">    <span class="built_in">channel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(loop, sockfd)),</span><br><span class="line">    <span class="built_in">localAddr_</span>(localAddr),</span><br><span class="line">    <span class="built_in">peerAddr_</span>(peerAddr),</span><br><span class="line">    <span class="built_in">highWaterMark_</span>(<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">&#123; </span><br><span class="line">    channel_-&gt;<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    channel_-&gt;<span class="built_in">setWriteCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));</span><br><span class="line">    channel_-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));</span><br><span class="line">    channel_-&gt;<span class="built_in">setErrorCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleError, <span class="keyword">this</span>));</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;TcpConnection::ctor[%s] at 0x%x fd=%d&quot;</span>, name_.<span class="built_in">c_str</span>(), <span class="keyword">this</span>, sockfd);</span><br><span class="line">    socket_-&gt;<span class="built_in">setKeepAlive</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress&amp; peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    EventLoop* ioLoop = eventLoopThreadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;:%s#%d&quot;</span>, hostport_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s&quot;</span>, name_.<span class="built_in">c_str</span>(), connName.<span class="built_in">c_str</span>(), peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">     </span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop, connName, sockfd, localAddr, peerAddr))</span></span>;</span><br><span class="line">    <span class="comment">//放入map容器管理</span></span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);<span class="comment">//指向业务层Session</span></span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, std::placeholders::_1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line">    <span class="comment">//该线程分离完io事件后，立即调用TcpConnection::connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	当Acceptor内通道检测到新连接事件最终回调到TcpServer的newConnection函数，参数还有对端的地址信息以及网络文件描述符，之后从线程池中获得一个线程的EventLoop，创建一个TcpConnection,可以看到在构造函数中传入eventloop，名称信息，文件描述符，对端，本端地址信息，并在构造函数中创建Channel，设置channel事件处理的回调。创建完毕，再向TcpConnection中传入到各个类的回调函数，最后在对应IO线程中调用connectEstablished。</p>
<p><strong>读事件处理</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int32_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//messageCallback_指向CTcpSession::OnRead(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receiveTime)</span></span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        <span class="built_in">LOGSYSE</span>(<span class="string">&quot;TcpConnection::handleRead&quot;</span>);</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由IO多路复用检测到读事件，随后通过Channel回调到TcpConnection::handleRead，之后再回调到我们用户设置的业务层Session的某个函数进行处理。</p>
<p><strong>写事件处理</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="type">int32_t</span> nwrote = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> remaining = len;</span><br><span class="line">    <span class="type">bool</span> faultError = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kDisconnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOGW</span>(<span class="string">&quot;disconnected, give up writing&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if no thing in output queue, try writing directly</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nwrote = sockets::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(), data, len);</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 打印threadid用于调试，后面去掉</span></span><br><span class="line">        <span class="comment">//std::stringstream ss;</span></span><br><span class="line">        <span class="comment">//ss &lt;&lt; std::this_thread::get_id();</span></span><br><span class="line">        <span class="comment">//LOGI &lt;&lt; &quot;send data in threadID = &quot; &lt;&lt; ss;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            remaining = len - nwrote;</span><br><span class="line">            <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)</span><br><span class="line">            &#123;</span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">LOGSYSE</span>(<span class="string">&quot;TcpConnection::sendInLoop&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="comment">// <span class="doctag">FIXME:</span> any others?</span></span><br><span class="line">                &#123;</span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//assert(remaining &lt;= len);</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &gt; len)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> oldLen = outputBuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">        <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_</span><br><span class="line">            &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class="line">            &amp;&amp; highWaterMarkCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(highWaterMarkCallback_, <span class="built_in">shared_from_this</span>(), oldLen + remaining));</span><br><span class="line">        &#125;</span><br><span class="line">        outputBuffer_.<span class="built_in">append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data) + nwrote, remaining);</span><br><span class="line">        <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            channel_-&gt;<span class="built_in">enableWriting</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (channel_-&gt;<span class="built_in">isWriting</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int32_t</span> n = sockets::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(), outputBuffer_.<span class="built_in">peek</span>(), outputBuffer_.<span class="built_in">readableBytes</span>());</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n);</span><br><span class="line">            <span class="keyword">if</span> (outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>();</span><br><span class="line">                <span class="keyword">if</span> (writeCompleteCallback_)</span><br><span class="line">                &#123;</span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (state_ == kDisconnecting)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOGSYSE</span>(<span class="string">&quot;TcpConnection::handleWrite&quot;</span>);</span><br><span class="line">            <span class="comment">// if (state_ == kDisconnecting)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//   shutdownInLoop();</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">//added by zhangyl 2019.05.06</span></span><br><span class="line">            <span class="built_in">handleClose</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOGD</span>(<span class="string">&quot;Connection fd = %d  is down, no more writing&quot;</span>, channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在类中重载了几个send()函数，实际上都会调用sendInLoop函数，那我们来看看sendInLoop这个函数。首先如果channel设置isWiriting或者发送缓冲区没有数据，那么将会直接调用write()。接下来会出现两种情况，一个是全部拷贝到了内核缓冲区，那么发送完毕，直接调用发送完成回调函数；二是遇到一些未发送或者未发送完全那么会压入发送缓冲区，如果超过缓冲区，则会触发高水位回调函数，采取一些措施，可能会关闭连接。压入缓冲区之后，然后使当前通道重新关注可写事件，当可写的时候，直接触发写回调，再写入缓冲区的字节。</p>
<p><strong>关闭连接事件处理:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void TcpConnection::handleClose()</span><br><span class="line">&#123;</span><br><span class="line">    if (state_ == kDisconnected)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    LOGD(&quot;fd = %d  state = %s&quot;, channel_-&gt;fd(), stateToString());</span><br><span class="line">    //assert(state_ == kConnected || state_ == kDisconnecting);</span><br><span class="line">    // we don&#x27;t close fd, leave it to dtor, so we can find leaks easily.</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    channel_-&gt;disableAll();</span><br><span class="line">     </span><br><span class="line">    TcpConnectionPtr guardThis(shared_from_this());</span><br><span class="line">    connectionCallback_(guardThis); //打印</span><br><span class="line">    // must be the last line</span><br><span class="line">    closeCallback_(guardThis);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void TcpServer::removeConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">    // FIXME: unsafe</span><br><span class="line">    loop_-&gt;runInLoop(std::bind(&amp;TcpServer::removeConnectionInLoop, this, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp; conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_</span><br><span class="line"></span><br><span class="line">-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;TcpServer::removeConnectionInLoop [%s] - connection %s&quot;</span>, name_.<span class="built_in">c_str</span>(), conn-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="type">size_t</span> n = connections_.<span class="built_in">erase</span>(conn-&gt;<span class="built_in">name</span>());</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//出现这种情况，是TcpConneaction对象在创建过程中，对方就断开连接了。</span></span><br><span class="line">        <span class="built_in">LOGD</span>(<span class="string">&quot;TcpServer::removeConnectionInLoop [%s] - connection %s, connection does not exist.&quot;</span>, name_.<span class="built_in">c_str</span>(), conn-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    EventLoop* ioLoop = conn-&gt;<span class="built_in">getLoop</span>();</span><br><span class="line">    ioLoop-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectDestroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">        channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    channel_-&gt;<span class="built_in">remove</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	关闭连接事件很重要，涉及到TcpConnection和Channel的生命周期以及是否能合理销毁，用了智能指针来管理和控制生命周期。下面我们就来分析一下断开流程中TcpConnection的引用计数问题：</p>
<p>1.首先连接到来创建TcpConnection，并存入容器。————————————————————————–引用计数+1  总数：1</p>
<p>2.客户端断开连接，在Channel的handleEvent函数中会将Channel中的TcpConnection弱指针提升————–引用计数+1  总数：2</p>
<p>3.触发HandleRead ，可读字节0，进而触发HandleClose,HandleClose函数中栈上的TcpConnectionPtr guardThis会继续将——————————————————————————————————————————————————引用计数+1  总数：3</p>
<p>4.触发HandleClose的回调函数 在TcpServer::removeConnection结束后(回归主线程队列)，释放HandleClose的栈指针，以及Channel里提升的指针—————————————————————————————————————-引用计数-2   总数：1</p>
<p>5.主线程执行回调removeConnectionInLoop，在函数内部将tcpconnection从TcpServer中保存连接容器中erase掉。但在removeConnectionInLoop结尾用conn为参数构造了bind。—————————————————————引用计数不变 总数：1</p>
<p>6.回归次线程处理connectDestroyed事件，结束完释放参数传递的最后一个shard_ptr，释放TcpConnection。——引用计数-1 总数：0</p>
<h2 id="TcpServer"><a href="#TcpServer" class="headerlink" title="TcpServer"></a>TcpServer</h2><p>TcpServer主要功能是管理新的连接到来时创建的TcpConnection，是直接提供给用户使用的类，生命周期由用户控制。</p>
<h3 id="成员变量：-3"><a href="#成员变量：-3" class="headerlink" title="成员变量："></a>成员变量：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	EventLoop*                                      loop_; <span class="comment">// the acceptor loop</span></span><br><span class="line">	<span class="type">const</span> string                                    hostport_;</span><br><span class="line">	<span class="type">const</span> string                                    name_;</span><br><span class="line">	std::unique_ptr&lt;Acceptor&gt;                       acceptor_; </span><br><span class="line">       std::unique_ptr&lt;EventLoopThreadPool&gt;            eventLoopThreadPool_;</span><br><span class="line">	ConnectionCallback                              connectionCallback_;</span><br><span class="line">	MessageCallback                                 messageCallback_;<span class="comment">//回调函数处理消息</span></span><br><span class="line">	WriteCompleteCallback                           writeCompleteCallback_;</span><br><span class="line">	ThreadInitCallback                              threadInitCallback_;</span><br><span class="line">	std::atomic&lt;<span class="type">int</span>&gt;                                started_; </span><br><span class="line">	<span class="type">int</span>                                             nextConnId_;</span><br><span class="line">	ConnectionMap                                   connections_;</span><br></pre></td></tr></table></figure>

<p>​	loop是主线程循环，hostport是传入的需要监听的端口，name是给服务端标记的名字，acceptor是一个新连接接受的对象，eventLoopThreadPool是线程池对象，之后创建了几个回调函数，回调了一些函数来处理一些自定义的消息，之后started_是线程池启动的标志位，nextConnid是标记连接的序号，最后的ConnectionMap是一个存放TcpConnection的容器。</p>
<h3 id="重要函数及作用：-5"><a href="#重要函数及作用：-5" class="headerlink" title="重要函数及作用："></a>重要函数及作用：</h3><p><strong>创建</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop* loop,</span><br><span class="line">    <span class="type">const</span> InetAddress&amp; listenAddr,</span><br><span class="line">    <span class="type">const</span> std::string&amp; nameArg,</span><br><span class="line">    Option option)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop),</span><br><span class="line">    <span class="built_in">hostport_</span>(listenAddr.<span class="built_in">toIpPort</span>()),</span><br><span class="line">    <span class="built_in">name_</span>(nameArg),</span><br><span class="line">    <span class="built_in">acceptor_</span>(<span class="keyword">new</span> <span class="built_in">Acceptor</span>(loop, listenAddr, option == kReusePort)),</span><br><span class="line">    <span class="comment">//threadPool_(new EventLoopThreadPool(loop, name_)),</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class="line">    <span class="built_in">messageCallback_</span>(defaultMessageCallback),</span><br><span class="line">    <span class="built_in">started_</span>(<span class="number">0</span>),</span><br><span class="line">    <span class="built_in">nextConnId_</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    acceptor_-&gt;<span class="built_in">setNewConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::newConnection, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在构造函数参数中传入了主线程循环，监听socket地址信息，初始化参数列表中用传入的参数和一些固定值初始化了一些变量，new了一个新连接接受处理类acceptor，设置了外部回调，然后在函数体中注册了一个这个类最关键的回调——新连接回调。</p>
<p><strong>启动线程池</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">(<span class="type">int</span> workerThreadCount<span class="comment">/* = 4*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(started_ == <span class="number">0</span>) <span class="comment">//没有启动</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//启动线程池管理</span></span><br><span class="line">        eventLoopThreadPool_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">EventLoopThreadPool</span>());</span><br><span class="line">        eventLoopThreadPool_-&gt;<span class="built_in">init</span>(loop_, workerThreadCount);</span><br><span class="line">        eventLoopThreadPool_-&gt;<span class="built_in">start</span>();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//threadPool_-&gt;start(threadInitCallback_);</span></span><br><span class="line">        <span class="comment">//assert(!acceptor_-&gt;listenning());</span></span><br><span class="line">     </span><br><span class="line">    	<span class="comment">//将函数对象放入队列或者立即执行</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen, acceptor_.<span class="built_in">get</span>()));<span class="comment">//监听端口并注册进多路复用</span></span><br><span class="line">        started_ = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	创建线程池，在线程池中会根据workerThreadCount创建对应线程，之后在当前循环(主线程循环)中进行端口的监听以及注册，置启动标志位为1。</p>
<p><strong>新连接到来</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress&amp; peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">	<span class="comment">//给新连接分配线程</span></span><br><span class="line">    EventLoop* ioLoop = eventLoopThreadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;:%s#%d&quot;</span>, hostport_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s&quot;</span>, name_.<span class="built_in">c_str</span>(), connName.<span class="built_in">c_str</span>(), peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">     </span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="comment">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class="line">    <span class="comment">// FIXME use make_shared if necessary</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop, connName, sockfd, localAddr, peerAddr))</span></span>;</span><br><span class="line">    <span class="comment">//放入map容器管理</span></span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);<span class="comment">//指向业务层Session</span></span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, std::placeholders::_1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line">    <span class="comment">//该线程分离完io事件后，立即调用TcpConnection::connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	由Accepter检测到新连接回调到TcpServer::newConnection，创建相应的TcpConnection并传入eventloop,对端地址簇，本段地址簇等信息，最后将TcpConnection传入Map容器，并向其注册一些回调函数。最后在对应线程的eventloop中调用连接建立函数。</p>
<p><strong>移除连接</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp; conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp; conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//主线程执行</span></span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;TcpServer::removeConnectionInLoop [%s] - connection %s&quot;</span>, name_.<span class="built_in">c_str</span>(), conn-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="type">size_t</span> n = connections_.<span class="built_in">erase</span>(conn-&gt;<span class="built_in">name</span>());  <span class="comment">//引用计数减1，当前应该是2</span></span><br><span class="line">    <span class="comment">//(void)n;</span></span><br><span class="line">    <span class="comment">//assert(n == 1);</span></span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//出现这种情况，是TcpConneaction对象在创建过程中，对方就断开连接了。</span></span><br><span class="line">        <span class="built_in">LOGD</span>(<span class="string">&quot;TcpServer::removeConnectionInLoop [%s] - connection %s, connection does not exist.&quot;</span>, name_.<span class="built_in">c_str</span>(), conn-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    EventLoop* ioLoop = conn-&gt;<span class="built_in">getLoop</span>();</span><br><span class="line">    ioLoop-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行完这个函数 会释放handleclose栈上对象 引用计数-1</span></span><br><span class="line">	<span class="comment">//当前应该是1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	当连接断开时通过对应Channel的HandleEvent最终会调用到removeConnection函数，在函数中将removeConnectionInLoop加入主线程执行队列，之后在主线程执行removeConnectionInLoop函数。在removeConnectionInLoop中将需要断开连接的TcpConnection从map容器中移除，再在对应的线程eventloop中将其销毁，关于TcpConnection的生命周期还请看上篇博客。</p>
<p><strong>结束</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void TcpServer::stop()</span><br><span class="line">&#123;</span><br><span class="line">    if (started_ == 0)</span><br><span class="line">        return; </span><br><span class="line">    for (ConnectionMap::iterator it = connections_.begin(); it != connections_.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        TcpConnectionPtr conn = it-&gt;second;</span><br><span class="line">        it-&gt;second.reset();</span><br><span class="line">        conn-&gt;getLoop()-&gt;runInLoop(std::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">        conn.reset();</span><br><span class="line">    &#125;</span><br><span class="line">    eventLoopThreadPool_-&gt;stop();</span><br><span class="line">    started_ = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结束线程池，主动关闭销毁每个连接，没啥好讲的。</p>
<h2 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h2><p>Acceptor是创建在TcpServer内部的对象，内部会有一个Channel来专门处理新连接到来事件，新连接到来最终会回调给TcpServer的newconnection来创建新连接，其实前几期muduo内部的机制都讲完了，如果能够理解前面的部分，这两个类基本看下就能知道作用了。</p>
<h3 id="成员变量：-4"><a href="#成员变量：-4" class="headerlink" title="成员变量："></a>成员变量：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop*            loop_;</span><br><span class="line">    Socket                acceptSocket_; <span class="comment">//用于服务端监听的真正的socket</span></span><br><span class="line">    Channel               acceptChannel_;</span><br><span class="line">    NewConnectionCallback newConnectionCallback_;</span><br><span class="line">    <span class="type">bool</span>                  listenning_;</span><br></pre></td></tr></table></figure>

<p>​	loop是主线程循环，也从TcpServer中传入loop，acceptSocket是服务端监听socket，Channel是专门用于接受连接事件，放在了主IO线程的通道，newConnectionCallback_是注册回调，指向了TcpServer::newConnection(),listenning是监听中标志位。</p>
<h3 id="重要函数及作用：-6"><a href="#重要函数及作用：-6" class="headerlink" title="重要函数及作用："></a>重要函数及作用：</h3><p><strong>初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop* loop, <span class="type">const</span> InetAddress&amp; listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop),</span><br><span class="line">    <span class="built_in">acceptSocket_</span>(sockets::<span class="built_in">createNonblockingOrDie</span>()),</span><br><span class="line">    <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>()),</span><br><span class="line">    <span class="built_in">listenning_</span>(<span class="literal">false</span>)   </span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WIN64</span></span><br><span class="line">    idleFd_ = ::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">setReusePort</span>(reuseport);</span><br><span class="line">    acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr);</span><br><span class="line">    acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	由TcpServer创建，传入主线程循环loop，监听地址信息等参数，参数初始化列表中构造了acceptSocket和acceptChannel，函数体中设置socket信息以及设置了Channel到TcpServer的回调函数。</p>
<p><strong>监听</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>();          <span class="comment">//监听对应端口</span></span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>();  <span class="comment">//注册到poll中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	开始监听端口，并将acceptChannel注册到IO复用poll中去。</p>
<p><strong>处理新连接事件</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="comment">//FIXME loop until no more</span></span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr); <span class="comment">//返回创建的新的套接字</span></span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         string hostport = peerAddr.<span class="built_in">toIpPort</span>();</span><br><span class="line">         <span class="built_in">LOGD</span>(<span class="string">&quot;Accepts of %s&quot;</span>, hostport.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">//newConnectionCallback_实际指向TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)</span></span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sockets::<span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOGSYSE</span>(<span class="string">&quot;in Acceptor::handleRead&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WIN64</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EMFILE)</span><br><span class="line">        &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(idleFd_);</span><br><span class="line">            idleFd_ = ::<span class="built_in">accept</span>(acceptSocket_.<span class="built_in">fd</span>(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ::<span class="built_in">close</span>(idleFd_);</span><br><span class="line">            idleFd_ = ::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	由IO多路复用检测到事件，通过Channel处理可读事件，回调到该函数的handleRead()，最终触发TcpServer::newConnection创建新连接。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/31/lskypro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kinnx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kinnx's Binary world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/31/lskypro/" class="post-title-link" itemprop="url">更优雅的写博客：Lsky Pro + PicGo + Typora图床配置 （docker + 腾讯云）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-31 09:53:03 / 修改时间：10:48:48" itemprop="dateCreated datePublished" datetime="2022-05-31T09:53:03+08:00">2022-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Lsky Pro</strong> 是一个用于在线上传、管理图片的图床程序，中文名：兰空图床，你可以将它作为自己的云上相册，亦可以当作你的写作贴图库。</p>
<p><strong>PicGo:</strong> 一个用于快速上传图片并获取图片 URL 链接的工具</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/629575febaaa6.png" alt="image-20220531095714636"></p>
<h3 id="项目展示"><a href="#项目展示" class="headerlink" title="项目展示"></a>项目展示</h3><p>GitHub原项目地址（感谢作者的付出）：<a target="_blank" rel="noopener" href="https://github.com/lsky-org/lsky-pro%EF%BC%882.3k">https://github.com/lsky-org/lsky-pro（2.3k</a> star）</p>
<p>官网地址：<a target="_blank" rel="noopener" href="https://www.lsky.pro/">https://www.lsky.pro/</a></p>
<p>文档地址：<a target="_blank" rel="noopener" href="https://docs.lsky.pro/">https://docs.lsky.pro/</a></p>
<p>本期用的Docker镜像地址 （感谢@Allen Hua）：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/dko0/lsky-pro">https://hub.docker.com/r/dko0/lsky-pro</a></p>
<p>PicGo插件：lankong（再次感谢@Allen Hua）<a target="_blank" rel="noopener" href="https://hellodk.cn/post/964">https://hellodk.cn/post/964</a></p>
<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>服务器：腾讯轻量应用服务器<br>系统：Centos7.8<br>域名一枚，并做好解析到服务器上（公网地址）<br>Docker、Docker-compose（相关脚本）<br>Nginx Proxy Manager</p>
<h3 id="搭建方法"><a href="#搭建方法" class="headerlink" title="搭建方法"></a>搭建方法</h3><h4 id="基础docker设置"><a href="#基础docker设置" class="headerlink" title="基础docker设置"></a>基础docker设置</h4><p>初始化环境必要设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo -i        			              <span class="comment"># 切换到root用户</span></span><br><span class="line"></span><br><span class="line">yum update -y 		                  <span class="comment"># 升级packages</span></span><br><span class="line"></span><br><span class="line">yum install wget curl sudo vim git    <span class="comment"># 安装必要插件</span></span><br></pre></td></tr></table></figure>



<p>创建安装目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /root/data/docker_data/lsky-pro</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /root/data/docker_data/lsky-pro</span><br><span class="line"></span><br><span class="line">nano docker-compose.yml</span><br></pre></td></tr></table></figure>

<p>在 docker-compose.yml 填入以下内容</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">lsky-pro:</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">lsky-pro</span>			<span class="comment">#lsky-pro container</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">dko0/lsky-pro</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/root/data/docker_data/lsky-pro/lsky-pro-data:/var/www/html</span>  <span class="comment">#映射到本地</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">7791</span><span class="string">:80</span>						<span class="comment">#开放端口 外网7791 内网80</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MYSQL_HOST=mysql</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=lsky-pro</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MYSQL_USER=********</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=*******</span></span><br><span class="line">    <span class="attr">app:</span>									<span class="comment">#nginx proxy manager设置</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&#x27;jc21/nginx-proxy-manager:latest&#x27;</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;80:80&#x27;</span>							<span class="comment">#http端口</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;81:81&#x27;</span>							<span class="comment">#admin端口</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;443:443&#x27;</span>						<span class="comment">#https端口</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MYSQL_HOST=mysql</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=lsky-pro</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MYSQL_USER=********</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=*********</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">./data:/data</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">./letsencrypt:/etc/letsencrypt</span></span><br><span class="line">    <span class="attr">mysql:</span>									<span class="comment">#database</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">lsky-pro-db</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=lsky-pro</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">MYSQL_USER=lsky-pro</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=*******</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=*******</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">/root/data/docker_data/lsky-pro/db:/var/lib/mysql</span></span><br></pre></td></tr></table></figure>

<p>没问题的话，ctrl+x退出，按y保存，enter确认。</p>
<p>查看端口是否被占用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:7791  <span class="comment">#查看7791端口是否被占用，如果被占用，重新自定义一个端口</span></span><br></pre></td></tr></table></figure>

<p>如果出现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: lsof: command not found</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install lsof  <span class="comment">#安装lsof</span></span><br></pre></td></tr></table></figure>

<p>如果端口没有被占用，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d </span><br></pre></td></tr></table></figure>



<h4 id="利用Nginx-Proxy-Manager反向代理"><a href="#利用Nginx-Proxy-Manager反向代理" class="headerlink" title="利用Nginx Proxy Manager反向代理"></a>利用Nginx Proxy Manager反向代理</h4><p>在添加反向代理之前，确保你已经完成了域名解析</p>
<p>注意，对于Nginx Proxy Manager，可能存在系统占用默认端口80,443的情况，可以改端口号</p>
<p>访问NPM：</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/629579aaba5a9.png" alt="image-20220531101254392"></p>
<p>添加proxy host</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/629579cc78c0e.png" alt="image-20220531101328943"></p>
<p>申请SSL证书（如果不是默认端口80,443，申请SSL可能出现Internal Error）</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/629579e2ba065.png" alt="image-20220531101351462"></p>
<p>至此，访问：http:服务ip:7791 或者 域名 皆可登录  lsky-pro</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">1、不知道服务器IP，可以直接在命令行输入：curl ip.sb，会显示当前服务器的IP。</span><br><span class="line"></span><br><span class="line">2、遇到访问不了的情况，请在服务器系统的后台防火墙里打开对应端口。</span><br></pre></td></tr></table></figure>



<h4 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h4><p>安装界面 因为是docker容器配置，不需要自己搭建运行环境</p>
<img src="https://kinnx.xyz/i/2022/05/31/62957cd5ef725.png" alt="image-20220531102627370" style="zoom: 67%;" />



<p>配置数据库 ，因为docker-compose 把数据库和lsky安装在一起，所以数据库链接地址就是docker容器名</p>
<img src="https://kinnx.xyz/i/2022/05/31/62957d6caa639.png" alt="image-20220531102858072" style="zoom:67%;" />



<p>创建完成</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/62957db2b3790.png" alt="image-20220531103008352"></p>
<h3 id="配置PicGo和Typora"><a href="#配置PicGo和Typora" class="headerlink" title="配置PicGo和Typora"></a>配置PicGo和Typora</h3><h4 id="获取token配置PicGo"><a href="#获取token配置PicGo" class="headerlink" title="获取token配置PicGo"></a>获取token配置PicGo</h4><p>根据lsky-pro的接口，post请求获取token</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/62957e7cee5c2.png" alt="image-20220531103330402"></p>
<p>使用 <a target="_blank" rel="noopener" href="https://www.sojson.com/httpRequest/">https://www.sojson.com/httpRequest/</a></p>
<p>post的地址是 https:&#x2F;&#x2F;你的网站&#x2F;api&#x2F;v1&#x2F;tokens</p>
<p>然后参数就是email和password两个常规参数，直接post</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/62957ed3cf7a0.png" alt="image-20220531103456834"></p>
<p>在Response Body 找到token</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/62957f383d64a.png" alt="image-20220531103637378"></p>
<p>下载PicGo 插件 <a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a>    不同系统下载对应版本</p>
<p>在插件中寻找lankong 并且安装</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/62957f7e5c09b.png" alt="image-20220531103747922"></p>
<p>配置图床信息如图</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/62957fabac395.png" alt="image-20220531103833274"></p>
<p>注意Server为你的兰空图床站点，不要&#x2F;结尾                 Bearer和token中间有空格。</p>
<h4 id="typora配置PicGo"><a href="#typora配置PicGo" class="headerlink" title="typora配置PicGo"></a>typora配置PicGo</h4><p><img src="https://kinnx.xyz/i/2022/05/31/62958051d1ecd.png" alt="image-20220531104118391"></p>
<p>至此配置已完成</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">https://blog.laoda.de/archives/docker-compose-install-lskypro #教程</span><br><span class="line"></span><br><span class="line">https://github.com/lsky-org/lsky-pro							</span><br><span class="line"></span><br><span class="line">https://www.lsky.pro/</span><br><span class="line"></span><br><span class="line">https://docs.lsky.pro/</span><br><span class="line"></span><br><span class="line">https://www.sojson.com/httpRequest/</span><br><span class="line"></span><br><span class="line">本期用的Docker镜像地址 （感谢@Allen Hua）：https://hub.docker.com/r/dko0/lsky-pro</span><br><span class="line"></span><br><span class="line">PicGo插件：lankong（再次感谢@Allen Hua）https://hellodk.cn/post/964</span><br><span class="line"></span><br><span class="line">https://www.nesxc.com/1068/</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/30/Blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kinnx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kinnx's Binary world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/30/Blog/" class="post-title-link" itemprop="url">利用Hexo搭建个人博客</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-30 01:20:45" itemprop="dateCreated datePublished" datetime="2022-05-30T01:20:45+08:00">2022-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-31 10:51:44" itemprop="dateModified" datetime="2022-05-31T10:51:44+08:00">2022-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>直接到官网上下载安装即可<a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>
<p>安装完成可以用打开cmd检验一下是否安装成功，用 <code>node -v</code> 和 <code>npm -v</code> 命令检查版本</p>
<h3 id="设置npm在安装全局模块时的路径和环境变量"><a href="#设置npm在安装全局模块时的路径和环境变量" class="headerlink" title="设置npm在安装全局模块时的路径和环境变量"></a>设置npm在安装全局模块时的路径和环境变量</h3><p>因为如果不设置的话，安装模块的时候就会把模块装到C盘，占用C盘的空间，并且有可能安装好hexo后却无法使用，所以我们需要设置一下：</p>
<p>在 nodejs 文件夹中新建两个空文件夹 node_cache、node_global，如下图：**(两个文件夹需要管理员权限)**</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/6295828a72be8.png" alt="image-20220530010948623"></p>
<p>打开cmd，输入如下两个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">&quot;D:\nodejs\node_global&quot;</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">&quot;D:\nodejs\node_cache&quot;</span></span><br></pre></td></tr></table></figure>

<p>设置环境变量：<strong>win10系统 –&gt; 打开控制面板 –&gt; 系统 –&gt;高级系统设置 –&gt; 环境变量 ，</strong>然后在<strong>系统变量</strong>中新建一个变量名为“NODE_PATH”，值为“D:\nodejs\node_global\node_modules”</p>
<p>然后编辑<strong>用户变量</strong>里的Path，将相应npm的路径改为：D:\nodejs\node_global</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在 cmd 命令下执行 </p>
<p><code>npm install webpack -g</code></p>
<p>然后 webpack 这个模块已经在我们设置默认的文件夹中了：</p>
<p><img src="https://pic2.zhimg.com/80/v2-2b8ee5f8f53ab2db8fc6f9739e481de9_720w.jpg" alt="img"></p>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>Windows：下载并安装<a target="_blank" rel="noopener" href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p>
<p>Centos：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install git-core</span><br></pre></td></tr></table></figure>



<h2 id="二、安装Hexo"><a href="#二、安装Hexo" class="headerlink" title="二、安装Hexo"></a>二、安装Hexo</h2><p>先在GitHub上创立一个仓库，如下图：</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/629574236fdb1.png" alt="image-20220530005531819"></p>
<p>接下来就是安装Hexo，首先在D盘建立一个文件夹 Blog，点开 Blog 文件夹，鼠标右键打开 Git Bush Here，输入npm命令安装Hexo：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>



<p><img src="https://kinnx.xyz/i/2022/05/31/6295743dbe6e3.png" alt="image-20220530005951082"></p>
<p>安装完成后，输入 hexo init 命令初始化博客：</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/62957431c0911.png" alt="image-20220530010009104"></p>
<h3 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a>将Hexo部署到GitHub</h3><p>现在回到我们的 Blog 文件夹，用笔记本打开 _config.yml 文件</p>
<p>下滑到文件底部，填上如下内容：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/Kinnx/Kinnx.github.io.git  #仓库地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>然后回到 Blog 文件夹中，打开 Git Bash，安装Git部署插件，输入命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后分别输入以下三条命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>





<h2 id="三、解析域名"><a href="#三、解析域名" class="headerlink" title="三、解析域名"></a>三、解析域名</h2><p>打开 Blog 文件夹里的 source 文件夹，添加CNAME文件，可以先创建一个CNAME.txt文件，打开后写上域名 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xenoverse.cloud</span><br></pre></td></tr></table></figure>



<p>登录阿里云，点击控制台，在你已购买的域名后点击解析添加解析记录</p>
<p><img src="https://kinnx.xyz/i/2022/05/31/629574cd20a36.png" alt="image-20220531095210390"></p>
<h2 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h2><p>当前用得最多的是next主题，那为什么用得多呢？当然是符合大多数人的审美。我使用的是next(v7.7.1)，下载地址：<a href="https://link.zhihu.com/?target=https://github.com/theme-next/hexo-theme-next">theme-next&#x2F;hexo-theme-next</a></p>
<p>打开博客根目录Blog文件夹，右键Git Bash，输入如下代码将next主题下载到目录Blog&#x2F;themes：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>



<p>打开根目录下的_config.yml(称为<strong>站点配置文件</strong>)，修改主题（<strong>注意冒号后都要有空格</strong>）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title:   #标题</span><br><span class="line">subtitle: &#x27;&#x27;</span><br><span class="line">description:   #简介或者格言</span><br><span class="line">keywords:</span><br><span class="line">author:     #作者</span><br><span class="line">language: zh-CN     #主题语言</span><br><span class="line">timezone: Asia/Shanghai    #中国的时区</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next   #主题改为next</span><br></pre></td></tr></table></figure>

<p>然后</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>



<p>至此 Hexo博客的架构搭建完成</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/29/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kinnx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kinnx's Binary world">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/29/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-29 14:21:13" itemprop="dateCreated datePublished" datetime="2022-05-29T14:21:13+08:00">2022-05-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kinnx</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kinnx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
